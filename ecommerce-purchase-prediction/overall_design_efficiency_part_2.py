# -*- coding: utf-8 -*-
"""overall design efficiency part 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3RfHadsoMlTrxHAntEi161js8X0ypuv
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_curve, auc
df= pd.read_excel("/content/drive/MyDrive/Colab Notebooks/Dissertation/dataset.xlsx")

"""combininv the three columns to get total duration"""

df['Total_Duration'] = (df['Administrative_Duration'] +
                          df['Informational_Duration'] +
                          df['ProductRelated_Duration'])

df['Prop_Admin'] = df['Administrative_Duration'] / df['Total_Duration']
df['Prop_Info'] = df['Informational_Duration'] / df['Total_Duration']
df['Prop_Product'] = df['ProductRelated_Duration'] / df['Total_Duration']

df.info()

df.head(20)

""" Create a binary target variable for "efficiency" where  Efficient: Prop_Product > 0.5 (spending more than 50% of the time on Product pages).
Inefficient: Prop_Product <= 0.5 and high time on Prop_Admin or Prop_Info
"""

df['Efficiency']= ((df['Prop_Product'] > 0.5).astype(int))

df.head(20)

"""Now we can combine Efficiency and Revenue columns  to understand:
Sessions with Efficient design leading to purchases.
Sessions with Efficient design but no purchase (may indicate content issues).
Sessions with Inefficient design needing layout improvements.

2 if good
1 if was efficint but didnt lead to purchase
"""

df['Session_Category']= df.apply(
    lambda row: 2 if row['Efficiency']== 1 and row['Revenue']== True else
                (1 if row['Efficiency']== 1 and row['Revenue']== False else 0),axis=1

)

# Set pandas to display all rows
pd.set_option('display.max_rows', None)

# Display the first 100 rows
df.head(100)

# Count occurrences of each value
session_category_counts = df['Session_Category'].value_counts()

# Get the count for 2
num_twos = session_category_counts.get(2, 0)  # Returns 0 if 2 is not in the column
print(f"Number of 2s: {num_twos}")

"""Now, build  logistic regression model to predict the efficiency of sessions."""

X= df[['Prop_Admin', 'Prop_Info', 'Prop_Product' ]]
y= df['Session_Category']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

"""finding out the Nan values which will not allow logistic regression"""

print(X_train.isna().sum())

# Drop rows with NaN values in the features
X_train = X_train.dropna()
y_train = y_train[X_train.index]  # Ensure the target matches the filtered features

X_test = X_test.dropna()
y_test = y_test[X_test.index]

df.head(50)

# Create the logistic regression model
logistic_model = LogisticRegression(multi_class='multinomial', solver='lbfgs', max_iter=1000, random_state=42)

# Train the model
logistic_model.fit(X_train, y_train)

# Predict class labels for the test set
y_pred = logistic_model.predict(X_test)

# Predict probabilities for each class
y_pred_proba = logistic_model.predict_proba(X_test)

# Generate the classification report
print("Classification Report:\n")
print(classification_report(y_test, y_pred))

from sklearn.metrics import confusion_matrix

# Generate the confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Display the confusion matrix
print("Confusion Matrix:\n", conf_matrix)


import seaborn as sns
import matplotlib.pyplot as plt

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues", xticklabels=[0, 1, 2], yticklabels=[0, 1, 2])
plt.xlabel("Predicted Class")
plt.ylabel("True Class")
plt.title("Confusion Matrix")
plt.show()

len(df)

"""Identify which type of page has the highest average time spent. So higehst is Product and then admin"""

# Correlation matrix
correlation_matrix = df[['Administrative', 'Informational', 'ProductRelated']].corr()
print(correlation_matrix)